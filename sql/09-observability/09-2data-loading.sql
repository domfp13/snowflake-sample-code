USE ROLE SYSADMIN;
USE DATABASE SNOWPROCORE;
USE SCHEMA PUBLIC;

-- ****************************** 1.- Virtual Warehouse ******************************
-- A virtual warehouse is a cluster of compute resources in Snowflake. It is used to execute SQL queries and perform other data processing tasks.
CREATE OR REPLACE WAREHOUSE SNOWPROCORE WITH
    WAREHOUSE_SIZE = 'X-SMALL' -- { XSMALL | SMALL | MEDIUM | LARGE | XLARGE | XXLARGE | XXXLARGE | X4LARGE | X5LARGE | X6LARGE }
    MIN_CLUSTER_COUNT = 1
    MAX_CLUSTER_COUNT = 2
    SCALING_POLICY = ECONOMY -- { STANDARD | ECONOMY }
    AUTO_SUSPEND = 180
    AUTO_RESUME = TRUE
    INITIALLY_SUSPENDED = TRUE -- { TRUE | FALSE };
    MAX_CONCURRENCY_LEVEL = 4
    STATEMENT_QUEUED_TIMEOUT_IN_SECONDS = 600 -- DEFAULT VALUE = 0 
    STATEMENT_TIMEOUT_IN_SECONDS = 600 -- DEFAULT VALUE = 0
;

USE WAREHOUSE SNOWPROCORE;

-- ****************************** 2.- File Format and Stage ******************************
-- When you load data from a file into a table, you must describe the format of the file and specify how the data in the file should be interpreted and processed.
CREATE OR REPLACE FILE FORMAT SNOWPROCORE.PUBLIC.FILE_FORMAT_JSON_GENERIC
 TYPE = 'JSON'
 ENABLE_OCTAL = FALSE
 ALLOW_DUPLICATE  = TRUE
 STRIP_OUTER_ARRAY = TRUE
 STRIP_NULL_VALUES = TRUE
 IGNORE_UTF8_ERRORS = FALSE;

-- A stage is a location in Snowflake where data files are stored. You can use a stage to load data into tables, or to unload data from tables.
CREATE OR REPLACE STAGE SNOWPROCORE.PUBLIC.STAGE_EXTERNAL_ACCOUNTS
  URL='s3://snowflake-s3-sfc-demo-ep/accounts/'
  FILE_FORMAT = SNOWPROCORE.PUBLIC.FILE_FORMAT_JSON_GENERIC;

LS @SNOWPROCORE.PUBLIC.STAGE_EXTERNAL_ACCOUNTS;

-- Snowflake allows you to query the contents of a stage using a SELECT statement. This is useful for previewing the contents of a stage before loading the data into a table.
SELECT * FROM @SNOWPROCORE.PUBLIC.STAGE_EXTERNAL_ACCOUNTS (FILE_FORMAT => SNOWPROCORE.PUBLIC.FILE_FORMAT_JSON_GENERIC) SAMPLE(100 ROWS);

-- Apply a transformation to the data in the stage BEFORE loading it into a table.
SELECT $1:ACCESSIBLE_BALANCE::FLOAT AS ACCESSIBLE_BALANCE,
       $1:ACCOUNT_BALANCE::FLOAT AS ACCOUNT_BALANCE,
       $1:ACCOUNT_STATUS_CODE::INT AS ACCOUNT_STATUS_CODE,
       $1:ACCOUNT_UID::VARCHAR AS ACCOUNT_UID,
       $1:CDIC_HOLD_STATUS_CODE::INT AS CDIC_HOLD_STATUS_CODE,
       $1:CURRENCY_CODE::INT AS CURRENCY_CODE,
       $1:CURRENT_CDIC_HOLD_AMOUNT::FLOAT AS CURRENT_CDIC_HOLD_AMOUNT,
       $1:DEPOSITOR_ID::VARCHAR AS DEPOSITOR_ID,
       $1:INSURANCE_DETERMINATION_CATEGORY_TYPE_CODE::INT AS INSURANCE_DETERMINATION_CATEGORY_TYPE_CODE,
       $1:PRODUCT_CODE::INT AS PRODUCT_CODE,
       $1:REGISTERED_ACCOUNT_FLAG::BOOLEAN AS REGISTERED_ACCOUNT_FLAG,
       $1:REGISTERED_PLAN_TYPE_CODE::INT AS REGISTERED_PLAN_TYPE_CODE
FROM @SNOWPROCORE.PUBLIC.STAGE_EXTERNAL_ACCOUNTS
(FILE_FORMAT => SNOWPROCORE.PUBLIC.FILE_FORMAT_JSON_GENERIC) SAMPLE(100 ROWS);

-- ****************************** 3.- Loading data Into a Table ******************************
CREATE OR REPLACE TABLE SNOWPROCORE.PUBLIC.ACCOUNTS_INTERNAL_RAW (
    PAYLOAD VARIANT,
    LOAD_DATE TIMESTAMP_LTZ(9) DEFAULT CURRENT_TIMESTAMP()
);

COPY INTO SNOWPROCORE.PUBLIC.ACCOUNTS_INTERNAL_RAW (PAYLOAD)
FROM (
    SELECT $1 AS PAYLOAD
    FROM @SNOWPROCORE.PUBLIC.STAGE_EXTERNAL_ACCOUNTS (FILE_FORMAT => SNOWPROCORE.PUBLIC.FILE_FORMAT_JSON_GENERIC)
)
FILE_FORMAT = SNOWPROCORE.PUBLIC.FILE_FORMAT_JSON_GENERIC
--PATTERN = '.*.json.gz'
PATTERN = '.*.json'
ON_ERROR = 'skip_file'
PURGE = FALSE;

-- ****************************** 4.- Querying the Table ******************************
ALTER WAREHOUSE SNOWPROCORE SET WAREHOUSE_SIZE = SMALL;
SELECT * FROM SNOWPROCORE.PUBLIC.ACCOUNTS_INTERNAL_RAW;

-- ****************************** 5.- Flattening the RAW Table ******************************
CREATE OR REPLACE TABLE SNOWPROCORE.PUBLIC.ACCOUNTS (
    ACCESSIBLE_BALANCE                         FLOAT,
    ACCOUNT_BALANCE                            FLOAT,
    ACCOUNT_STATUS_CODE                        INT,
    ACCOUNT_UID                                VARCHAR,
    CDIC_HOLD_STATUS_CODE                      INT,
    CURRENCY_CODE                              INT,
    CURRENT_CDIC_HOLD_AMOUNT                   FLOAT,
    DEPOSITOR_ID                               VARCHAR,
    INSURANCE_DETERMINATION_CATEGORY_TYPE_CODE INT,
    PRODUCT_CODE                               INT,
    REGISTERED_ACCOUNT_FLAG                    BOOLEAN,
    REGISTERED_PLAN_TYPE_CODE                  INT
);

-- Flatten the table
INSERT INTO SNOWPROCORE.PUBLIC.ACCOUNTS
SELECT $1:ACCESSIBLE_BALANCE::FLOAT AS ACCESSIBLE_BALANCE,
       $1:ACCOUNT_BALANCE::FLOAT AS ACCOUNT_BALANCE,
       $1:ACCOUNT_STATUS_CODE::INT AS ACCOUNT_STATUS_CODE,
       $1:ACCOUNT_UID::VARCHAR AS ACCOUNT_UID,
       $1:CDIC_HOLD_STATUS_CODE::INT AS CDIC_HOLD_STATUS_CODE,
       $1:CURRENCY_CODE::INT AS CURRENCY_CODE,
       $1:CURRENT_CDIC_HOLD_AMOUNT::FLOAT AS CURRENT_CDIC_HOLD_AMOUNT,
       $1:DEPOSITOR_ID::VARCHAR AS DEPOSITOR_ID,
       $1:INSURANCE_DETERMINATION_CATEGORY_TYPE_CODE::INT AS INSURANCE_DETERMINATION_CATEGORY_TYPE_CODE,
       $1:PRODUCT_CODE::INT AS PRODUCT_CODE,
       $1:REGISTERED_ACCOUNT_FLAG::BOOLEAN AS REGISTERED_ACCOUNT_FLAG,
       $1:REGISTERED_PLAN_TYPE_CODE::INT AS REGISTERED_PLAN_TYPE_CODE
FROM SNOWPROCORE.PUBLIC.ACCOUNTS_INTERNAL_RAW;

-- Query the table
SELECT * FROM SNOWPROCORE.PUBLIC.ACCOUNTS;

-- ****************************** 6.- Data Protection ****************************** 
-- Change some records in the table
UPDATE SNOWPROCORE.PUBLIC.ACCOUNTS
SET ACCOUNT_BALANCE = 0
WHERE CDIC_HOLD_STATUS_CODE = 1;

-- Time travel to see the changes
SELECT * FROM SNOWPROCORE.PUBLIC.ACCOUNTS BEFORE(STATEMENT => '');

INSERT OVERWRITE INTO SNOWPROCORE.PUBLIC.ACCOUNTS
SELECT * FROM SNOWPROCORE.PUBLIC.ACCOUNTS BEFORE(STATEMENT => '');

SELECT * FROM SNOWPROCORE.PUBLIC.ACCOUNTS;

-- ****************************** 7.- Data Governance ******************************
-- ***** Dynamic Data Masking
USE ROLE SYSADMIN;
USE DATABASE SNOWPROCORE;
USE SCHEMA PUBLIC;

-- Create a masking policy that prevents non-administrative users from seeing the actual values in the id column of the account table.
CREATE OR REPLACE MASKING POLICY BALANCE_MASK AS (VAL FLOAT) RETURNS FLOAT -> 
    CASE
    WHEN CURRENT_ROLE() IN ('SYSADMIN', 'ACCOUNTADMIN') THEN VAL
    ELSE 0.0
END;

-- Apply masking to the account table
ALTER TABLE IF EXISTS SNOWPROCORE.PUBLIC.ACCOUNTS MODIFY COLUMN ACCESSIBLE_BALANCE SET MASKING POLICY BALANCE_MASK;
ALTER TABLE IF EXISTS SNOWPROCORE.PUBLIC.ACCOUNTS MODIFY COLUMN ACCOUNT_BALANCE SET MASKING POLICY BALANCE_MASK;

-- Test the masking policy
SELECT * FROM SNOWPROCORE.PUBLIC.ACCOUNTS;

USE ROLE ANALYST;
USE WAREHOUSE COMPUTE_WH;
USE DATABASE SNOWPROCORE;
USE SCHEMA PUBLIC;

SELECT * FROM SNOWPROCORE.PUBLIC.ACCOUNTS;

-- ***** Row Access Policies
USE ROLE SYSADMIN;
USE DATABASE SNOWPROCORE;
CREATE OR REPLACE SCHEMA UTILITIES COMMENT = 'This schema contains utility tables and objects';
USE SCHEMA UTILITIES;

CREATE OR REPLACE TABLE SNOWPROCORE.UTILITIES.PRODUCT_CODE_POLICY_MAPPING (
    PRODUCT_CODE    INT,
    ROLE_NAME       VARCHAR
);

-- Create a row access policy that prevents non-administrative users from seeing the actual values in the PRODUCT_CODE COLUMN of the account table.
INSERT INTO SNOWPROCORE.UTILITIES.PRODUCT_CODE_POLICY_MAPPING(PRODUCT_CODE, ROLE_NAME) VALUES
  (1, 'ANALYST'),
  (2, 'ANALYST'),
  (3, 'ANALYST');

SELECT * FROM SNOWPROCORE.UTILITIES.PRODUCT_CODE_POLICY_MAPPING;

-- Creating the row access policy
CREATE OR REPLACE ROW ACCESS POLICY UTILITIES.PRODUCT_CODE_POLICY
AS (PRODUCT_CODE INT) RETURNS BOOLEAN ->
  CURRENT_ROLE() IN ('ACCOUNTADMIN','SYSADMIN')
    OR EXISTS (
      SELECT 1 
      FROM SNOWPROCORE.UTILITIES.PRODUCT_CODE_POLICY_MAPPING pcpm
        WHERE ROLE_NAME = CURRENT_ROLE()
        AND pcpm.PRODUCT_CODE = PRODUCT_CODE
    )
;

USE ROLE SYSADMIN;
ALTER TABLE SNOWPROCORE.PUBLIC.ACCOUNTS ADD ROW ACCESS POLICY SNOWPROCORE.UTILITIES.PRODUCT_CODE_POLICY ON (PRODUCT_CODE);
SELECT * FROM SNOWPROCORE.PUBLIC.ACCOUNTS SAMPLE(100); -- SYSADMIN CAN SEE ALL THE RECORDS
SELECT COUNT(*) FROM SNOWPROCORE.PUBLIC.ACCOUNTS SAMPLE(100); 

-- LETS USE THE ANALYST ROLE
USE ROLE ANALYST;
USE WAREHOUSE COMPUTE_WH;
USE DATABASE SNOWPROCORE;
USE SCHEMA PUBLIC;
SELECT * FROM SNOWPROCORE.PUBLIC.ACCOUNTS SAMPLE(100);
SELECT COUNT(*) FROM SNOWPROCORE.PUBLIC.ACCOUNTS SAMPLE(100);

-- ***** Projection policy
--A projection policy is a first-class, schema-level object that defines whether a column can be projected in the output of a SQL query result. A column with a projection policy assigned to it is said to be projection constrained.
USE ROLE SYSADMIN;
USE DATABASE SNOWPROCORE;
USE WAREHOUSE SNOWPROCORE;
USE SCHEMA PUBLIC;

CREATE OR REPLACE PROJECTION POLICY PROJECTION_POLICY_ACCOUNT_REGISTER_ACCOUNT
    AS () RETURNS PROJECTION_CONSTRAINT ->
    CASE
    WHEN CURRENT_ROLE() IN ('SYSADMIN', 'ACCOUNTADMIN')
        THEN PROJECTION_CONSTRAINT(ALLOW => true)
    ELSE PROJECTION_CONSTRAINT(ALLOW => false)
END;

ALTER TABLE SNOWPROCORE.PUBLIC.ACCOUNTS
 MODIFY COLUMN REGISTERED_ACCOUNT_FLAG
 SET PROJECTION POLICY PROJECTION_POLICY_ACCOUNT_REGISTER_ACCOUNT;

SELECT * FROM SNOWPROCORE.PUBLIC.ACCOUNTS SAMPLE(100);

USE ROLE ANALYST;
USE WAREHOUSE COMPUTE_WH;
USE DATABASE SNOWPROCORE;
USE SCHEMA PUBLIC;
SELECT * FROM SNOWPROCORE.PUBLIC.ACCOUNTS SAMPLE(100);
SELECT * EXCLUDE (REGISTERED_ACCOUNT_FLAG) FROM SNOWPROCORE.PUBLIC.ACCOUNTS SAMPLE(100);

-- ***** Aggreation policy
-- When an aggregation policy is applied to a table, queries against that table must aggregate data into groups of a minimum size in order to return results
USE ROLE SYSADMIN;
USE DATABASE SNOWPROCORE;
USE WAREHOUSE SNOWPROCORE;
USE SCHEMA PUBLIC;
ALTER TABLE SNOWPROCORE.PUBLIC.ACCOUNTS MODIFY COLUMN REGISTERED_ACCOUNT_FLAG UNSET PROJECTION POLICY;
CREATE AGGREGATION POLICY AGGREGATION_POLICY_ACCOUNT_REGISTER_PLAN_TYPE_CODE
  AS () RETURNS AGGREGATION_CONSTRAINT ->
    CASE
      WHEN CURRENT_ROLE() IN ('SYSADMIN', 'ACCOUNTADMIN')
        THEN NO_AGGREGATION_CONSTRAINT()
      ELSE AGGREGATION_CONSTRAINT(MIN_GROUP_SIZE => 1)
    END;

ALTER TABLE SNOWPROCORE.PUBLIC.ACCOUNTS SET AGGREGATION POLICY AGGREGATION_POLICY_ACCOUNT_REGISTER_PLAN_TYPE_CODE;
SELECT * FROM SNOWPROCORE.PUBLIC.ACCOUNTS SAMPLE(100);

-- USING ANALYST
USE ROLE ANALYST;
USE WAREHOUSE COMPUTE_WH;
USE DATABASE SNOWPROCORE;
USE SCHEMA PUBLIC;
SELECT * FROM SNOWPROCORE.PUBLIC.ACCOUNTS SAMPLE(100);
SELECT COUNT(*) FROM SNOWPROCORE.PUBLIC.ACCOUNTS SAMPLE(100);
SELECT REGISTERED_PLAN_TYPE_CODE, COUNT(*) FROM SNOWPROCORE.PUBLIC.ACCOUNTS GROUP BY REGISTERED_PLAN_TYPE_CODE;

-- ****************************** 8.- Cleanup ******************************
-- Remove column policy
USE ROLE SYSADMIN;
ALTER TABLE SNOWPROCORE.PUBLIC.ACCOUNTS DROP ALL ROW ACCESS POLICIES;
ALTER TABLE SNOWPROCORE.PUBLIC.ACCOUNTS ALTER COLUMN ACCOUNT_BALANCE UNSET MASKING POLICY;
ALTER TABLE SNOWPROCORE.PUBLIC.ACCOUNTS ALTER COLUMN ACCESSIBLE_BALANCE UNSET MASKING POLICY;
ALTER TABLE SNOWPROCORE.PUBLIC.ACCOUNTS MODIFY COLUMN REGISTERED_ACCOUNT_FLAG UNSET PROJECTION POLICY;
ALTER TABLE SNOWPROCORE.PUBLIC.ACCOUNTS UNSET AGGREGATION POLICY;
DROP MASKING POLICY BALANCE_MASK;
DROP ROW ACCESS POLICY UTILITIES.PRODUCT_CODE_POLICY;
DROP PROJECTION POLICY PROJECTION_POLICY_ACCOUNT_REGISTER_ACCOUNT;
DROP AGGREGATION POLICY AGGREGATION_POLICY_ACCOUNT_REGISTER_PLAN_TYPE_CODE;
DROP TABLE IF EXISTS SNOWPROCORE.PUBLIC.ACCOUNTS_INTERNAL_RAW;
DROP FILE FORMAT IF EXISTS SNOWPROCORE.PUBLIC.FILE_FORMAT_JSON_GENERIC;
DROP STAGE IF EXISTS SNOWPROCORE.PUBLIC.STAGE_EXTERNAL_ACCOUNTS;
DROP TABLE IF EXISTS SNOWPROCORE.PUBLIC.ACCOUNTS;
DROP SCHEMA IF EXISTS SNOWPROCORE.UTILITIES;